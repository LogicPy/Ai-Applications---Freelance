# examine.py

import joblib
import os
import matplotlib.pyplot as plt
import numpy as np
from data_processing.preprocess import load_vectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns

def load_model(model_path):
    """
    Loads the trained model from the specified path.
    
    Args:
        model_path (str): Path to the model file.
    
    Returns:
        model: The loaded machine learning model.
    """
    if os.path.exists(model_path):
        model = joblib.load(model_path)
        print(f"Model loaded successfully from {model_path}.")
        return model
    else:
        raise FileNotFoundError(f"Model file not found at {model_path}.")

def load_vectorizer(vectorizer_path):
    """
    Loads the TF-IDF vectorizer from the specified path.
    
    Args:
        vectorizer_path (str): Path to the vectorizer file.
    
    Returns:
        vectorizer: The loaded TF-IDF vectorizer.
    """
    if os.path.exists(vectorizer_path):
        vectorizer = joblib.load(vectorizer_path)
        print(f"Vectorizer loaded successfully from {vectorizer_path}.")
        return vectorizer
    else:
        raise FileNotFoundError(f"Vectorizer file not found at {vectorizer_path}.")

def display_model_parameters(model):
    """
    Displays the model's parameters.
    
    Args:
        model: The trained machine learning model.
    """
    print("\n=== Model Parameters ===")
    for param, value in model.get_params().items():
        print(f"{param}: {value}")

def display_model_coefficients(model, vectorizer):
    """
    Displays the top features (coefficients) for each class in a Logistic Regression model.
    
    Args:
        model: The trained Logistic Regression model.
        vectorizer: The loaded TF-IDF vectorizer.
    """
    if isinstance(model, LogisticRegression):
        print("\n=== Model Coefficients ===")
        feature_names = vectorizer.get_feature_names_out()
        for class_idx, class_label in enumerate(model.classes_):
            coef = model.coef_[class_idx]
            coef_dict = dict(zip(feature_names, coef))
            sorted_coefs = sorted(coef_dict.items(), key=lambda item: item[1], reverse=True)
            print(f"\nTop 10 features for class '{class_label}':")
            for feature, weight in sorted_coefs[:10]:
                print(f"{feature}: {weight:.4f}")
        
        # Optional: Visualize the top coefficients for each class
        visualize_coefficients(model, vectorizer)
    else:
        print("The model is not an instance of LogisticRegression. Skipping coefficient display.")

def visualize_coefficients(model, vectorizer):
    """
    Visualizes the top coefficients for each class using bar charts.
    
    Args:
        model: The trained Logistic Regression model.
        vectorizer: The loaded TF-IDF vectorizer.
    """
    feature_names = vectorizer.get_feature_names_out()
    for class_idx, class_label in enumerate(model.classes_):
        coef = model.coef_[class_idx]
        top_positive_indices = np.argsort(coef)[-10:]
        top_negative_indices = np.argsort(coef)[:10]
        
        top_positive_features = feature_names[top_positive_indices]
        top_positive_coefficients = coef[top_positive_indices]
        
        top_negative_features = feature_names[top_negative_indices]
        top_negative_coefficients = coef[top_negative_indices]
        
        plt.figure(figsize=(10, 6))
        sns.barplot(x=top_positive_coefficients, y=top_positive_features, color='green', label='Positive Coefficients')
        sns.barplot(x=top_negative_coefficients, y=top_negative_features, color='red', label='Negative Coefficients')
        plt.title(f"Top Coefficients for '{class_label}'")
        plt.xlabel("Coefficient Value")
        plt.ylabel("Feature")
        plt.legend()
        plt.tight_layout()
        plt.show()

def evaluate_model(model, vectorizer, training_data_path):
    """
    Evaluates the model using a subset of the training data.
    
    Args:
        model: The trained machine learning model.
        vectorizer: The loaded TF-IDF vectorizer.
        training_data_path (str): Path to the training data file.
    """
    if not os.path.exists(training_data_path):
        print(f"Training data file not found at {training_data_path}. Skipping evaluation.")
        return
    
    # Load training data
    with open(training_data_path, 'r', encoding='utf-8') as file:
        data = file.read().split('\n\n')  # Assuming double newline separates entries
    
    texts = []
    labels = []
    for entry in data:
        if not entry.strip():
            continue
        lines = entry.strip().split('\n')
        label = lines[0].strip()  # Assuming first line is label
        text = ' '.join(lines[1:]).strip()  # Remaining lines are description
        texts.append(text)
        labels.append(label)
    
    # Vectorize texts
    X = vectorizer.transform(texts)
    y = labels
    
    # Predict
    predictions = model.predict(X)
    
    # Classification Report
    print("\n=== Classification Report ===")
    print(classification_report(y, predictions))
    
    # Confusion Matrix
    cm = confusion_matrix(y, predictions, labels=model.classes_)
    plt.figure(figsize=(10, 8))
    sns.heatmap(cm, annot=True, fmt='d', xticklabels=model.classes_, yticklabels=model.classes_, cmap='Blues')
    plt.xlabel('Predicted')
    plt.ylabel('True')
    plt.title('Confusion Matrix')
    plt.show()

def main():
    # Define paths
    MODEL_PATH = os.path.join('models', 'model_name.pkl')
    VECTORIZER_PATH = os.path.join('models', 'vectorizer.pkl')
    TRAINING_DATA_PATH = os.path.join('training.txt')
    
    # Load model and vectorizer
    model = load_model(MODEL_PATH)
    vectorizer = load_vectorizer(VECTORIZER_PATH)
    
    # Display model parameters
    display_model_parameters(model)
    
    # Display model coefficients and visualize
    display_model_coefficients(model, vectorizer)
    
    # Evaluate model performance
    evaluate_model(model, vectorizer, TRAINING_DATA_PATH)

if __name__ == "__main__":
    main()
