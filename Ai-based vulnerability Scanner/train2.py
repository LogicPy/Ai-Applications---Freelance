# train2.py

from sklearn.linear_model import LogisticRegression  # Using LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
import joblib
import os
import matplotlib.pyplot as plt
import seaborn as sns

# Import load_vectorizer from preprocess.py
from data_processing.preprocess import load_vectorizer

# Paths
MODEL_PATH = os.path.join('models', 'model_name.pkl')
TRAINING_DATA_PATH = os.path.join('training.txt')

def load_training_data():
    """
    Loads and preprocesses the training data.
    
    Returns:
        texts (list): List of vulnerability descriptions.
        labels (list): Corresponding list of vulnerability labels.
    """
    if not os.path.exists(TRAINING_DATA_PATH):
        raise FileNotFoundError(f"Training data file not found at {TRAINING_DATA_PATH}")
    with open(TRAINING_DATA_PATH, 'r', encoding='utf-8') as file:
        data = file.read().split('\n\n')  # Assuming double newline separates entries
    texts = []
    labels = []
    for entry in data:
        if not entry.strip():
            continue
        lines = entry.strip().split('\n')
        label = lines[0].strip()  # Assuming first line is label
        text = ' '.join(lines[1:]).strip()  # Remaining lines are description
        texts.append(text)
        labels.append(label)
    return texts, labels

def train_model():
    """
    Trains the Logistic Regression model from scratch and saves it to disk.
    """
    vectorizer = load_vectorizer()  # Load the existing vectorizer
    texts, labels = load_training_data()
    X = vectorizer.transform(texts)
    y = labels

    # Split the data for evaluation
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Initialize the model
    model = LogisticRegression(max_iter=1000, solver='lbfgs', multi_class='auto')
    print("Created new Logistic Regression model.")

    # Train the model
    model.fit(X_train, y_train)
    print("Model trained successfully.")

    # Evaluate the model
    predictions = model.predict(X_test)
    report = classification_report(y_test, predictions)
    print("Classification Report:\n", report)

    # Plot Confusion Matrix
    cm = confusion_matrix(y_test, predictions, labels=model.classes_)
    plt.figure(figsize=(10, 8))
    sns.heatmap(cm, annot=True, fmt='d', xticklabels=model.classes_, yticklabels=model.classes_, cmap='Blues')
    plt.xlabel('Predicted')
    plt.ylabel('True')
    plt.title('Confusion Matrix')
    plt.tight_layout()
    plt.savefig('confusion_matrix.png')  # Save the plot
    plt.show()

    # Save the trained model
    joblib.dump(model, MODEL_PATH)
    print(f"Model saved successfully at {MODEL_PATH}")

if __name__ == "__main__":
    train_model()
