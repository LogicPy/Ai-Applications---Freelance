{"ast":null,"code":"import { Color, ColorManagement, Matrix3, SRGBColorSpace, Vector2, Vector3 } from 'three';\nclass OBJExporter {\n  parse(object) {\n    let output = '';\n    let indexVertex = 0;\n    let indexVertexUvs = 0;\n    let indexNormals = 0;\n    const vertex = new Vector3();\n    const color = new Color();\n    const normal = new Vector3();\n    const uv = new Vector2();\n    const face = [];\n    function parseMesh(mesh) {\n      let nbVertex = 0;\n      let nbNormals = 0;\n      let nbVertexUvs = 0;\n      const geometry = mesh.geometry;\n      const normalMatrixWorld = new Matrix3();\n\n      // shortcuts\n      const vertices = geometry.getAttribute('position');\n      const normals = geometry.getAttribute('normal');\n      const uvs = geometry.getAttribute('uv');\n      const indices = geometry.getIndex();\n\n      // name of the mesh object\n      output += 'o ' + mesh.name + '\\n';\n\n      // name of the mesh material\n      if (mesh.material && mesh.material.name) {\n        output += 'usemtl ' + mesh.material.name + '\\n';\n      }\n\n      // vertices\n\n      if (vertices !== undefined) {\n        for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.fromBufferAttribute(vertices, i);\n\n          // transform the vertex to world space\n          vertex.applyMatrix4(mesh.matrixWorld);\n\n          // transform the vertex to export format\n          output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n        }\n      }\n\n      // uvs\n\n      if (uvs !== undefined) {\n        for (let i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n          uv.fromBufferAttribute(uvs, i);\n\n          // transform the uv to export format\n          output += 'vt ' + uv.x + ' ' + uv.y + '\\n';\n        }\n      }\n\n      // normals\n\n      if (normals !== undefined) {\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n        for (let i = 0, l = normals.count; i < l; i++, nbNormals++) {\n          normal.fromBufferAttribute(normals, i);\n\n          // transform the normal to world space\n          normal.applyMatrix3(normalMatrixWorld).normalize();\n\n          // transform the normal to export format\n          output += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n        }\n      }\n\n      // faces\n\n      if (indices !== null) {\n        for (let i = 0, l = indices.count; i < l; i += 3) {\n          for (let m = 0; m < 3; m++) {\n            const j = indices.getX(i + m) + 1;\n            face[m] = indexVertex + j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + j : '') + (normals ? '/' + (indexNormals + j) : '') : '');\n          }\n\n          // transform the face to export format\n          output += 'f ' + face.join(' ') + '\\n';\n        }\n      } else {\n        for (let i = 0, l = vertices.count; i < l; i += 3) {\n          for (let m = 0; m < 3; m++) {\n            const j = i + m + 1;\n            face[m] = indexVertex + j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + j : '') + (normals ? '/' + (indexNormals + j) : '') : '');\n          }\n\n          // transform the face to export format\n          output += 'f ' + face.join(' ') + '\\n';\n        }\n      }\n\n      // update index\n      indexVertex += nbVertex;\n      indexVertexUvs += nbVertexUvs;\n      indexNormals += nbNormals;\n    }\n    function parseLine(line) {\n      let nbVertex = 0;\n      const geometry = line.geometry;\n      const type = line.type;\n\n      // shortcuts\n      const vertices = geometry.getAttribute('position');\n\n      // name of the line object\n      output += 'o ' + line.name + '\\n';\n      if (vertices !== undefined) {\n        for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.fromBufferAttribute(vertices, i);\n\n          // transform the vertex to world space\n          vertex.applyMatrix4(line.matrixWorld);\n\n          // transform the vertex to export format\n          output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n        }\n      }\n      if (type === 'Line') {\n        output += 'l ';\n        for (let j = 1, l = vertices.count; j <= l; j++) {\n          output += indexVertex + j + ' ';\n        }\n        output += '\\n';\n      }\n      if (type === 'LineSegments') {\n        for (let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n          output += 'l ' + (indexVertex + j) + ' ' + (indexVertex + k) + '\\n';\n        }\n      }\n\n      // update index\n      indexVertex += nbVertex;\n    }\n    function parsePoints(points) {\n      let nbVertex = 0;\n      const geometry = points.geometry;\n      const vertices = geometry.getAttribute('position');\n      const colors = geometry.getAttribute('color');\n      output += 'o ' + points.name + '\\n';\n      if (vertices !== undefined) {\n        for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex.fromBufferAttribute(vertices, i);\n          vertex.applyMatrix4(points.matrixWorld);\n          output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n          if (colors !== undefined) {\n            color.fromBufferAttribute(colors, i);\n            ColorManagement.fromWorkingColorSpace(color, SRGBColorSpace);\n            output += ' ' + color.r + ' ' + color.g + ' ' + color.b;\n          }\n          output += '\\n';\n        }\n        output += 'p ';\n        for (let j = 1, l = vertices.count; j <= l; j++) {\n          output += indexVertex + j + ' ';\n        }\n        output += '\\n';\n      }\n\n      // update index\n      indexVertex += nbVertex;\n    }\n    object.traverse(function (child) {\n      if (child.isMesh === true) {\n        parseMesh(child);\n      }\n      if (child.isLine === true) {\n        parseLine(child);\n      }\n      if (child.isPoints === true) {\n        parsePoints(child);\n      }\n    });\n    return output;\n  }\n}\nexport { OBJExporter };","map":{"version":3,"names":["Color","ColorManagement","Matrix3","SRGBColorSpace","Vector2","Vector3","OBJExporter","parse","object","output","indexVertex","indexVertexUvs","indexNormals","vertex","color","normal","uv","face","parseMesh","mesh","nbVertex","nbNormals","nbVertexUvs","geometry","normalMatrixWorld","vertices","getAttribute","normals","uvs","indices","getIndex","name","material","undefined","i","l","count","fromBufferAttribute","applyMatrix4","matrixWorld","x","y","z","getNormalMatrix","applyMatrix3","normalize","m","j","getX","join","parseLine","line","type","k","parsePoints","points","colors","fromWorkingColorSpace","r","g","b","traverse","child","isMesh","isLine","isPoints"],"sources":["C:/Users/Admin/Desktop/threejs_ide/threejs-ide/frontend/node_modules/three/examples/jsm/exporters/OBJExporter.js"],"sourcesContent":["import {\n\tColor,\n\tColorManagement,\n\tMatrix3,\n\tSRGBColorSpace,\n\tVector2,\n\tVector3\n} from 'three';\n\nclass OBJExporter {\n\n\tparse( object ) {\n\n\t\tlet output = '';\n\n\t\tlet indexVertex = 0;\n\t\tlet indexVertexUvs = 0;\n\t\tlet indexNormals = 0;\n\n\t\tconst vertex = new Vector3();\n\t\tconst color = new Color();\n\t\tconst normal = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\tconst face = [];\n\n\t\tfunction parseMesh( mesh ) {\n\n\t\t\tlet nbVertex = 0;\n\t\t\tlet nbNormals = 0;\n\t\t\tlet nbVertexUvs = 0;\n\n\t\t\tconst geometry = mesh.geometry;\n\n\t\t\tconst normalMatrixWorld = new Matrix3();\n\n\t\t\t// shortcuts\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t// name of the mesh object\n\t\t\toutput += 'o ' + mesh.name + '\\n';\n\n\t\t\t// name of the mesh material\n\t\t\tif ( mesh.material && mesh.material.name ) {\n\n\t\t\t\toutput += 'usemtl ' + mesh.material.name + '\\n';\n\n\t\t\t}\n\n\t\t\t// vertices\n\n\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( vertices, i );\n\n\t\t\t\t\t// transform the vertex to world space\n\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = uvs.count; i < l; i ++, nbVertexUvs ++ ) {\n\n\t\t\t\t\tuv.fromBufferAttribute( uvs, i );\n\n\t\t\t\t\t// transform the uv to export format\n\t\t\t\t\toutput += 'vt ' + uv.x + ' ' + uv.y + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\tfor ( let i = 0, l = normals.count; i < l; i ++, nbNormals ++ ) {\n\n\t\t\t\t\tnormal.fromBufferAttribute( normals, i );\n\n\t\t\t\t\t// transform the normal to world space\n\t\t\t\t\tnormal.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t// transform the normal to export format\n\t\t\t\t\toutput += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// faces\n\n\t\t\tif ( indices !== null ) {\n\n\t\t\t\tfor ( let i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\tfor ( let m = 0; m < 3; m ++ ) {\n\n\t\t\t\t\t\tconst j = indices.getX( i + m ) + 1;\n\n\t\t\t\t\t\tface[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// transform the face to export format\n\t\t\t\t\toutput += 'f ' + face.join( ' ' ) + '\\n';\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\tfor ( let m = 0; m < 3; m ++ ) {\n\n\t\t\t\t\t\tconst j = i + m + 1;\n\n\t\t\t\t\t\tface[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// transform the face to export format\n\t\t\t\t\toutput += 'f ' + face.join( ' ' ) + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\t\t\tindexVertexUvs += nbVertexUvs;\n\t\t\tindexNormals += nbNormals;\n\n\t\t}\n\n\t\tfunction parseLine( line ) {\n\n\t\t\tlet nbVertex = 0;\n\n\t\t\tconst geometry = line.geometry;\n\t\t\tconst type = line.type;\n\n\t\t\t// shortcuts\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\n\t\t\t// name of the line object\n\t\t\toutput += 'o ' + line.name + '\\n';\n\n\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( vertices, i );\n\n\t\t\t\t\t// transform the vertex to world space\n\t\t\t\t\tvertex.applyMatrix4( line.matrixWorld );\n\n\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( type === 'Line' ) {\n\n\t\t\t\toutput += 'l ';\n\n\t\t\t\tfor ( let j = 1, l = vertices.count; j <= l; j ++ ) {\n\n\t\t\t\t\toutput += ( indexVertex + j ) + ' ';\n\n\t\t\t\t}\n\n\t\t\t\toutput += '\\n';\n\n\t\t\t}\n\n\t\t\tif ( type === 'LineSegments' ) {\n\n\t\t\t\tfor ( let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1 ) {\n\n\t\t\t\t\toutput += 'l ' + ( indexVertex + j ) + ' ' + ( indexVertex + k ) + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\n\t\t}\n\n\t\tfunction parsePoints( points ) {\n\n\t\t\tlet nbVertex = 0;\n\n\t\t\tconst geometry = points.geometry;\n\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\tconst colors = geometry.getAttribute( 'color' );\n\n\t\t\toutput += 'o ' + points.name + '\\n';\n\n\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( vertices, i );\n\t\t\t\t\tvertex.applyMatrix4( points.matrixWorld );\n\n\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n\n\t\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\t\tcolor.fromBufferAttribute( colors, i );\n\n\t\t\t\t\t\tColorManagement.fromWorkingColorSpace( color, SRGBColorSpace );\n\n\t\t\t\t\t\toutput += ' ' + color.r + ' ' + color.g + ' ' + color.b;\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutput += '\\n';\n\n\t\t\t\t}\n\n\t\t\t\toutput += 'p ';\n\n\t\t\t\tfor ( let j = 1, l = vertices.count; j <= l; j ++ ) {\n\n\t\t\t\t\toutput += ( indexVertex + j ) + ' ';\n\n\t\t\t\t}\n\n\t\t\t\toutput += '\\n';\n\n\t\t\t}\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\n\t\t}\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\tparseMesh( child );\n\n\t\t\t}\n\n\t\t\tif ( child.isLine === true ) {\n\n\t\t\t\tparseLine( child );\n\n\t\t\t}\n\n\t\t\tif ( child.isPoints === true ) {\n\n\t\t\t\tparsePoints( child );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn output;\n\n\t}\n\n}\n\nexport { OBJExporter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}