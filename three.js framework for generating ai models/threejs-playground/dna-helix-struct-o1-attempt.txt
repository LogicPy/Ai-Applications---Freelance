// DNA Helix Visualization in Three.js

// Initialize grid and score globally
const GRID_WIDTH = 10;
const GRID_HEIGHT = 20;
const CELL_SIZE = 1;

// Define tetromino spawn Y position (adjusted to center the falling blocks)
const TETROMINO_SPAWN_Y = 10; // Lowered from GRID_HEIGHT to position blocks closer to the camera

window.grid = Array.from({ length: GRID_HEIGHT }, () => Array(GRID_WIDTH).fill(null));
window.score = 0;

// Initialize tetrominoes array globally
window.tetrominoes = [];

// Create a floor plane
const floorGeometry = new THREE.PlaneGeometry(GRID_WIDTH * CELL_SIZE, GRID_WIDTH * CELL_SIZE);
const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, opacity: 0.5, transparent: true });
const floor = new THREE.Mesh(floorGeometry, floorMaterial);
floor.rotation.x = -Math.PI / 2;
floor.position.y = -0.5; // Align with grid
floor.receiveShadow = true;
scene.add(floor);

// Add grid helper for visualization
const gridHelper = new THREE.GridHelper(GRID_WIDTH * CELL_SIZE, GRID_WIDTH, 0x000000, 0x000000);
gridHelper.rotation.x = -Math.PI / 2;
scene.add(gridHelper);

// Add axes helper
const axesHelper = new THREE.AxesHelper(5);
scene.add(axesHelper);

// Add lighting
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(0, 50, 50);
directionalLight.castShadow = true;
directionalLight.shadow.mapSize.width = 1024;
directionalLight.shadow.mapSize.height = 1024;
scene.add(directionalLight);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
scene.add(ambientLight);

// Define the shapes and their colors
const shapes = [
  { 
    name: 'Cube', 
    geometry: new THREE.BoxGeometry(1, 1, 1), 
    color: 0xff0000, // Red
    cells: [
      [0,0,0],
      [1,0,0],
      [0,1,0],
      [1,1,0],
    ] // 2x2 Cube
  },
  { 
    name: 'Long', 
    geometry: new THREE.BoxGeometry(1, 1, 1), 
    color: 0x00ff00, // Green
    cells: [
      [0,0,0],
      [0,1,0],
      [0,2,0],
      [0,3,0],
    ] // 4x1 Line
  },
  { 
    name: 'L-Shape', 
    geometry: new THREE.BoxGeometry(1, 1, 1), 
    color: 0x0000ff, // Blue
    cells: [
      [0,0,0],
      [0,1,0],
      [0,2,0],
      [1,2,0],
    ] // L-shape
  },
  { 
    name: 'T-Shape', 
    geometry: new THREE.BoxGeometry(1, 1, 1), 
    color: 0xffff00, // Yellow
    cells: [
      [0,1,0],
      [1,0,0],
      [1,1,0],
      [2,1,0],
    ] // T-shape
  },
  { 
    name: 'S-Shape', 
    geometry: new THREE.BoxGeometry(1, 1, 1), 
    color: 0xff00ff, // Magenta
    cells: [
      [0,1,0],
      [1,1,0],
      [1,0,0],
      [2,0,0],
    ] // S-shape
  },
  // Add more shapes as needed
];

// Function to generate helix points with phase offset
function generateHelixPoints(numTurns, radius, risePerTurn, phase) {
  const points = [];
  const totalPoints = numTurns * Math.PI * 2;
  const step = 0.1; // Smaller step for smoother curve

  for (let t = 0; t <= numTurns * Math.PI * 2; t += step) {
    const x = radius * Math.cos(t + phase);
    const y = risePerTurn * t / (Math.PI * 2);
    const z = radius * Math.sin(t + phase);
    points.push(new THREE.Vector3(x, y, z));
  }

  return points;
}

// Create backbone curves with phase offset (180 degrees)
const backbone1Points = generateHelixPoints(10, 5, 1, 0);
const backbone2Points = generateHelixPoints(10, 5, 1, Math.PI);

// Create TubeGeometries for backbones
const backboneCurve1 = new THREE.CatmullRomCurve3(backbone1Points);
const backboneCurve2 = new THREE.CatmullRomCurve3(backbone2Points);

const backboneGeometry = new THREE.TubeGeometry(backboneCurve1, 1000, 0.2, 8, false);
const backboneMaterial = new THREE.MeshStandardMaterial({
  color: 0xd3d3d3,
  metalness: 0.5,
  roughness: 0.5,
  transparent: true,
  opacity: 0.8,
});
const backboneMesh1 = new THREE.Mesh(backboneGeometry, backboneMaterial);
backboneMesh1.castShadow = true;
backboneMesh1.receiveShadow = true;
scene.add(backboneMesh1);

const backboneGeometry2 = new THREE.TubeGeometry(backboneCurve2, 1000, 0.2, 8, false);
const backboneMesh2 = new THREE.Mesh(backboneGeometry2, backboneMaterial);
backboneMesh2.castShadow = true;
backboneMesh2.receiveShadow = true;
scene.add(backboneMesh2);

// Nitrogenous bases
const baseGeometry = new THREE.BoxGeometry(0.6, 0.2, 0.2);
const baseMaterial = new THREE.MeshPhongMaterial({
  shininess: 50,
});

// Define base pair materials
const adenineMaterial = baseMaterial.clone();
adenineMaterial.color = new THREE.Color(0xff0000); // Red

const thymineMaterial = baseMaterial.clone();
thymineMaterial.color = new THREE.Color(0x0000ff); // Blue

const cytosineMaterial = baseMaterial.clone();
cytosineMaterial.color = new THREE.Color(0x00ff00); // Green

const guanineMaterial = baseMaterial.clone();
guanineMaterial.color = new THREE.Color(0xffff00); // Yellow

// Base pairing pattern: A-T and C-G
const basePairs = [
  { pair1: adenineMaterial, pair2: thymineMaterial },
  { pair1: cytosineMaterial, pair2: guanineMaterial },
];

// Create base pairs along the helix
const basePairSpacing = Math.PI * 2; // Every full turn

for (let i = 0; i <= 10 * Math.PI * 2; i += basePairSpacing / 2) { // Base pairs every half turn
  // Choose base pair type randomly
  const randomPair = basePairs[Math.floor(Math.random() * basePairs.length)];

  // Position on backbone1
  const x1 = 5 * Math.cos(i);
  const y1 = 1 * i / (Math.PI * 2);
  const z1 = 5 * Math.sin(i);

  // Position on backbone2 (180 degrees apart)
  const x2 = 5 * Math.cos(i + Math.PI);
  const y2 = 1 * i / (Math.PI * 2);
  const z2 = 5 * Math.sin(i + Math.PI);

  // Create base pair1 on backbone1
  const basePair1 = new THREE.Mesh(baseGeometry, randomPair.pair1);
  basePair1.position.set(x1, y1, z1);
  scene.add(basePair1);

  // Create base pair2 on backbone2
  const basePair2 = new THREE.Mesh(baseGeometry, randomPair.pair2);
  basePair2.position.set(x2, y2, z2);
  scene.add(basePair2);

  // Create hydrogen bonds between basePair1 and basePair2
  const bondGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 16, 1);
  const bondMaterial = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    opacity: 0.6,
    transparent: true,
    blending: THREE.AdditiveBlending,
  });

  const bond = new THREE.Mesh(bondGeometry, bondMaterial);
  bond.position.set((x1 + x2) / 2, (y1 + y2) / 2, (z1 + z2) / 2);
  bond.lookAt(new THREE.Vector3(x2, y2, z2));
  scene.add(bond);
}

// Central axis (optional, to visualize the center)
const axisGeometry = new THREE.CylinderGeometry(0.1, 0.1, 10, 16);
const axisMaterial = new THREE.MeshBasicMaterial({
  color: 0xadd8e6,
  opacity: 0.1,
  transparent: true,
  side: THREE.DoubleSide,
});
const axisMesh = new THREE.Mesh(axisGeometry, axisMaterial);
axisMesh.position.set(0, 5, 0);
scene.add(axisMesh);

// Lighting
const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1.0);
directionalLight2.position.set(1, 1, 1);
directionalLight2.castShadow = true;
directionalLight2.shadow.mapSize.width = 1024;
directionalLight2.shadow.mapSize.height = 1024;
scene.add(directionalLight2);

const ambientLight2 = new THREE.AmbientLight(0xffffff, 0.2);
scene.add(ambientLight2);
